NDContentPage.OnToolTipsLoaded({54:"<div class=\"NDToolTip TMacro LSystemVerilog\"><div class=\"TTSummary\">Xilinx VIP macro for information which gives informative message when LEVEL is bigger than 300.&nbsp; Else, it is silent.</div></div>",59:"<div class=\"NDToolTip TType LSystemVerilog\"><div class=\"TTSummary\">Xilinx VIP Interger unsigned data type</div></div>",60:"<div class=\"NDToolTip TType LSystemVerilog\"><div class=\"TTSummary\">Xilinx VIP verbosity data type. When verbosity is bigger than 300, information will be printed out</div></div>",78:"<div class=\"NDToolTip TClass LSystemVerilog\"><div class=\"TTSummary\">The xil_object class is the base class for all Xilinx Verification Component data and hierarchical classes. Its primary role is to define a set of methods for common operations such as set name, verbosity, tag etc.</div></div>",93:"<div class=\"NDToolTip TClass LSystemVerilog\"><div class=\"TTSummary\">The xil_reporter class is a class which extends from xil_object and add its own get_type_name function</div></div>",97:"<div class=\"NDToolTip TClass LSystemVerilog\"><div class=\"TTSummary\">The xil_componennt class is a class which extends from xil_reporter and added its own new and get_type_name function</div></div>",101:"<div class=\"NDToolTip TClass LSystemVerilog\"><div class=\"TTSummary\">The xil_agent class is a class which extends from xil_component.</div></div>",108:"<div class=\"NDToolTip TClass LSystemVerilog\"><div class=\"TTSummary\">The xil_analysis_port is a parameterized class which extends from xil_component</div></div>",117:"<div class=\"NDToolTip TClass LSystemVerilog\"><div class=\"TTSummary\">xil_sqr_if_base is a base class which provides the interfaces necessary in order to receive or send sequence items and/or other sequences. xil_sqr_if_base #(T1, T2)</div></div>",133:"<div class=\"NDToolTip TClass LSystemVerilog\"><div class=\"TTSummary\">The xil_seq_item_pull_port#(REQ,RSP) class is extends from xil_sqr_if_base. It inherits all these variables and functions of xil_sqr_if_base.</div></div>",136:"<div class=\"NDToolTip TClass LSystemVerilog\"><div class=\"TTSummary\">The xil_driver#(REQ, RSP) class is parameterized class which extends from xil_component.It is the base class of all xilinx VIP\'s driver class. It has one port which is seq_item_port</div></div>",365:"<div class=\"NDToolTip TType LSystemVerilog\"><div class=\"TTSummary\">Xilinx AXI VIP int data type</div></div>",367:"<div class=\"NDToolTip TType LSystemVerilog\"><div class=\"TTSummary\">Xilinx AXI VIP Interger unsigned data type</div></div>",368:"<div class=\"NDToolTip TType LSystemVerilog\"><div class=\"TTSummary\">Xilinx AXI VIP longint unsigned data type</div></div>",369:"<div class=\"NDToolTip TType LSystemVerilog\"><div class=\"TTSummary\">Xilinx AXI VIP payload byte data type</div></div>",371:"<div class=\"NDToolTip TType LSystemVerilog\"><div class=\"TTSummary\">Xilinx AXI VIP User beat data type</div></div>",372:"<div class=\"NDToolTip TType LSystemVerilog\"><div class=\"TTSummary\">Xilinx AXI VIP data beat data type</div></div>",373:"<div class=\"NDToolTip TType LSystemVerilog\"><div class=\"TTSummary\">Xilinx AXI VIP Strobe beat data type</div></div>",375:"<div class=\"NDToolTip TType LSystemVerilog\"><div class=\"TTSummary\">Xilinx AXI VIP transaction Length data type</div></div>",376:"<div class=\"NDToolTip TType LSystemVerilog\"><div class=\"TTSummary\">Xilinx AXI VIP transaction Cache data type</div></div>",377:"<div class=\"NDToolTip TType LSystemVerilog\"><div class=\"TTSummary\">Xilinx AXI VIP transaction Prot data type</div></div>",378:"<div class=\"NDToolTip TType LSystemVerilog\"><div class=\"TTSummary\">Xilinx AXI VIP transaction Region data type</div></div>",379:"<div class=\"NDToolTip TType LSystemVerilog\"><div class=\"TTSummary\">Xilinx AXI VIP transaction QOS data type</div></div>",380:"<div class=\"NDToolTip TType LSystemVerilog\"><div class=\"TTSummary\">Policies used by the memory model when it is determining what operation to perform when it encounters an empty entry. It can fill in the memory model with some fixed default value( user has to set this value through set_default_value_memory_value) or randomly generated value.</div></div>",381:"<div class=\"NDToolTip TType LSystemVerilog\"><div class=\"TTSummary\">Policies used by the memory model te determine how to insert inter-beat gaps.</div></div>",382:"<div class=\"NDToolTip TType LSystemVerilog\"><div class=\"TTSummary\">Definitions of the AXI AxSIZE values in a transaction.</div></div>",383:"<div class=\"NDToolTip TType LSystemVerilog\"><div class=\"TTSummary\">Definitions of the AXI AxLOCK values which defines access type of transaction.</div></div>",384:"<div class=\"NDToolTip TType LSystemVerilog\"><div class=\"TTSummary\">Definitions of the AXI BRESP and RRESP values of transaction.</div></div>",385:"<div class=\"NDToolTip TType LSystemVerilog\"><div class=\"TTSummary\">Definitions of the AXI AxBURST values of transaction.</div></div>",386:"<div class=\"NDToolTip TType LSystemVerilog\"><div class=\"TTSummary\">Enumeration of the possible transaction direction from the perspective of the master.</div></div>",387:"<div class=\"NDToolTip TType LSystemVerilog\"><div class=\"TTSummary\">Policies of the transaction to inform the driver whether to return the transaction back to the issuer Depending on the policy the driver will return the transaction a different points in the life of the transaction</div></div>",388:"<div class=\"NDToolTip TType LSystemVerilog\"><div class=\"TTSummary\">This policy type informs the driver if the driver can re-order transactions that it is still processing.&nbsp; For READ transactions, the driver can return the RDATA beats from different RID\'s in a different order than they were received.&nbsp; For WRITE transactions, the driver uses this policy to determine if it can return BRESP\'s in a different order than they were received.</div></div>",389:"<div class=\"NDToolTip TType LSystemVerilog\"><div class=\"TTSummary\">Collection of policies that describe how the xREADY signals will behave. These policies can introduce backpressure into the system to find design faults, refer PG267 section about READY Generation for more details.</div></div>",390:"<div class=\"NDToolTip TType LSystemVerilog\"><div class=\"TTSummary\">Collection of policies that describe how the xREADY signals will behave when xil_axi_ready_gen_policy is XIL_AXI_READY_GEN_RANDOM.&nbsp; refer PG267 section about READY Generation for more details.</div></div>",391:"<div class=\"NDToolTip TType LSystemVerilog\"><div class=\"TTSummary\">Xilinx AXI VIP Boolean data type</div></div>",392:"<div class=\"NDToolTip TType LSystemVerilog\"><div class=\"TTSummary\">When VIF driver is in idle mode, possible signals that can be driven on VIF</div></div>",393:"<div class=\"NDToolTip TType LSystemVerilog\"><div class=\"TTSummary\">Diffferent data pattern of transaction.</div></div>",394:"<div class=\"NDToolTip TType LSystemVerilog\"><div class=\"TTSummary\">The order between write command and write data</div></div>",395:"<div class=\"NDToolTip TType LSystemVerilog\"><div class=\"TTSummary\">AXI transaction write data insertion delay policy</div></div>",396:"<div class=\"NDToolTip TType LSystemVerilog\"><div class=\"TTSummary\">AXI protocol version type</div></div>",397:"<div class=\"NDToolTip TType LSystemVerilog\"><div class=\"TTSummary\">Pattern of filling in data into transacation</div></div>",398:"<div class=\"NDToolTip TType LSystemVerilog\"><div class=\"TTSummary\">Pattern of filling in strobe into transaction</div></div>",413:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype413\" class=\"NDPrototype WideForm CStyle\"><table><tr><td class=\"PBeforeParameters\"><span class=\"SHKeyword\">function void</span> set_bready_gen(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">input&nbsp;</td><td class=\"PType\">axi_ready_gen_t&nbsp;</td><td class=\"PName last\">new_gen</td></tr></table></td><td class=\"PAfterParameters\">);</td></tr></table></div><div class=\"TTSummary\">Sets bready of the AXI master write driver. There are three ways for bready generation in AXI master write driver.</div></div>",473:"<div class=\"NDToolTip TClass LSystemVerilog\"><div class=\"TTSummary\">XIL AXI Channel Beat Base class, single bus beat for the Write Channel.&nbsp; It inherits all the methods of xil_sequence_item</div></div>",479:"<div class=\"NDToolTip TClass LSystemVerilog\"><div class=\"TTSummary\">XIL AXI data channel beat base object, it inherits all the methods and member from xil_axi_channel_beat_base</div></div>",486:"<div class=\"NDToolTip TClass LSystemVerilog\"><div class=\"TTSummary\">XIL AXI write beat class, it inherits all the methods and members of&nbsp; xil_axi_data_channel_beat_base</div></div>",497:"<div class=\"NDToolTip TClass LSystemVerilog\"><div class=\"TTSummary\">XIL AXI RESP beat class. Single bus beat for the RESP channel. It inherits all the member and methods of xil_axidata_channel_beat_base.</div></div>",500:"<div class=\"NDToolTip TClass LSystemVerilog\"><div class=\"TTSummary\">XIL AXI read beat class. Single bus beat for the READ channel. It inherits all the member and methods of xil_axi_resp_beat.</div></div>",516:"<div class=\"NDToolTip TClass LSystemVerilog\"><div class=\"TTSummary\">The axi_transaction class is the base class of AXI protocol. It inherits all the methods of xil_sequence_item.</div></div>",520:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype520\" class=\"NDPrototype NoParameterForm\"><span class=\"SHKeyword\">virtual function string</span> cmd_convert2string();</div><div class=\"TTSummary\">Returns the string of the AXI basic command properties which are cmd name,cmd_id,addr,id,length,size name, burst name, cache,lock name and prot. This is debugging tool to observe the transaction.</div></div>",631:"<div class=\"NDToolTip TClass LSystemVerilog\"><div class=\"TTSummary\">AXI VIF Proxy Class. It has virtual interface for AXI VIP interface.</div></div>",663:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype663\" class=\"NDPrototype WideForm CStyle\"><table><tr><td class=\"PBeforeParameters\"><span class=\"SHKeyword\">virtual function void</span> set_xfer_wrcmd_order(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">input&nbsp;</td><td class=\"PType\">xil_axi_xfer_wrcmd_order_t&nbsp;</td><td class=\"PName last\">update</td></tr></table></td><td class=\"PAfterParameters\">);</td></tr></table></div><div class=\"TTSummary\">Sets xfer_wrcmd_order of the transaction.</div></div>",714:"<div class=\"NDToolTip TClass LSystemVerilog\"><div class=\"TTSummary\">AXI Master Write Driver class.</div></div>",741:"<div class=\"NDToolTip TClass LSystemVerilog\"><div class=\"TTSummary\">AXI Scoreboard Transaction class.</div></div>",747:"<div class=\"NDToolTip TClass LSystemVerilog\"><div class=\"TTSummary\">AXI Ready generation class.</div></div>",752:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype752\" class=\"NDPrototype WideForm CStyle\"><table><tr><td class=\"PBeforeParameters\"><span class=\"SHKeyword\">function void</span> set_rready_gen(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">input&nbsp;</td><td class=\"PType\">axi_ready_gen_t&nbsp;</td><td class=\"PName last\">new_method</td></tr></table></td><td class=\"PAfterParameters\">);</td></tr></table></div><div class=\"TTSummary\">Sets rready of the AXI master read driver. There are three ways for rready generation in AXI master read driver.</div></div>",753:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype753\" class=\"NDPrototype WideForm CStyle\"><table><tr><td class=\"PBeforeParameters\"><span class=\"SHKeyword\">function void</span> set_awready_gen(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">input&nbsp;</td><td class=\"PType\">axi_ready_gen_t&nbsp;</td><td class=\"PName last\">new_gen</td></tr></table></td><td class=\"PAfterParameters\">);</td></tr></table></div><div class=\"TTSummary\">Sets awready of the AXI slave write driver. There are three ways for awready generation in AXI slave write driver.</div></div>",754:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype754\" class=\"NDPrototype WideForm CStyle\"><table><tr><td class=\"PBeforeParameters\"><span class=\"SHKeyword\">function void</span> set_wready_gen(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">input&nbsp;</td><td class=\"PType\">axi_ready_gen_t&nbsp;</td><td class=\"PName last\">new_gen</td></tr></table></td><td class=\"PAfterParameters\">);</td></tr></table></div><div class=\"TTSummary\">Sets wready of the AXI slave write driver. There are three ways for wready generation in AXI slave write driver.</div></div>",758:"<div class=\"NDToolTip TClass LSystemVerilog\"><div class=\"TTSummary\">XIL AXI cmd beat class. Single bus beat for the CMD channel, it inherits all the member and methods of xil_axi_channel_beat_base. It includes read/write, addr, id, burst, len, size, lock, cache, prot,region,qos,user</div></div>",760:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype760\" class=\"NDPrototype WideForm CStyle\"><table><tr><td class=\"PBeforeParameters\"><span class=\"SHKeyword\">function void</span> set_arready_gen(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">input&nbsp;</td><td class=\"PType\">axi_ready_gen_t&nbsp;</td><td class=\"PName last\">new_method</td></tr></table></td><td class=\"PAfterParameters\">);</td></tr></table></div><div class=\"TTSummary\">Sets arready of the AXI slave read driver. There are three ways for arready generation in AXI slave read driver.</div></div>",763:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype763\" class=\"NDPrototype WideForm CStyle\"><table><tr><td class=\"PBeforeParameters\">task send_arready(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">input&nbsp;</td><td class=\"PType\">axi_ready_gen&nbsp;</td><td class=\"PName last\">t</td></tr></table></td><td class=\"PAfterParameters\">);</td></tr></table></div><div class=\"TTSummary\">Sends the ready structure to the slave read driver for controlling the ARREADY channel. This is blocking process which will not return till this ready is being sent out.</div></div>",863:"<div class=\"NDToolTip TClass LSystemVerilog\"><div class=\"TTSummary\">When active the AXI Monitor will record transactions that are presented on the virtual interface.It does below functions: Monitors all 5 AXI channels: AW, AR, R, W, and B.&nbsp; Collects and re-orders R Channel beats and returns a completed transaction when the RLAST is accepted Collects and re-orders B Channel response and returns a completed transaction when the B channel is accepted Transaction based protocol checking</div></div>",889:"<div class=\"NDToolTip TClass LSystemVerilog\"><div class=\"TTSummary\">AXI Passthrough Agent Class.</div></div>",919:"<div class=\"NDToolTip TClass LSystemVerilog\"><div class=\"TTSummary\">An extension of axi_passthrough_agent with memory model.</div></div>",939:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype939\" class=\"NDPrototype NoParameterForm\"><span class=\"SHKeyword\">virtual function</span> xil_axi_uint get_low_time();</div><div class=\"TTSummary\">Returns low time of the current ready generation. if ready policy is XIL_AXI_READY_GEN_NO_BACKPRESSURE, low time is 0, else if ready policy is XIL_AXI_READY_GEN_RANDOM or get_use_variable_ranges is TRUE, low is the randomly generated low time.&nbsp; else low time is low_time of current ready generation.</div></div>",960:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype960\" class=\"NDPrototype WideForm CStyle\"><table><tr><td class=\"PBeforeParameters\">task send_bready(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">input&nbsp;</td><td class=\"PType\">axi_ready_gen&nbsp;</td><td class=\"PName last\">t</td></tr></table></td><td class=\"PAfterParameters\">);</td></tr></table></div><div class=\"TTSummary\">Sends the ready structure to the axi_mst_wr_driver for controlling the READY channel.&nbsp; Usually user would create a new axi_ready_gen by calling create_ready of axi_mst_wr_driver, either randomize the bready or set it up manually. Then it calls send to send the bready to axi_mst_wr_driver.</div></div>",964:"<div class=\"NDToolTip TClass LSystemVerilog\"><div class=\"TTSummary\">AXI Master Read Driver class.</div></div>",967:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype967\" class=\"NDPrototype NoParameterForm\"><span class=\"SHKeyword\">virtual function</span> xil_axi_uint get_high_time();</div><div class=\"TTSummary\">Returns high time of axi_ready_gen. If ready policy is XIL_AXI_READY_GEN_NO_BACKPRESSURE, returns 1, else if ready policy is XIL_AXI_READY_GEN_RANDOM or get_use_variable_ranges is TRUE, high time is the randomly generated high time.&nbsp; else high time is high_time of current ready generation.High_time is how many cycles ready stay high.</div></div>",977:"<div class=\"NDToolTip TClass LSystemVerilog\"><div class=\"TTSummary\">AXI Slave Write Driver Class.It does : Receives AW Command and the WLAST from the interface and then passes that transaction to the user environment, the user will then create a BRESP transaction and pass it back to the driver to drive the B channel.</div></div>",1000:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype1000\" class=\"NDPrototype WideForm CStyle\"><table><tr><td class=\"PBeforeParameters\"><span class=\"SHKeyword\">function void</span> set_forward_progress_timeout_value (</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">input&nbsp;</td><td class=\"PType\">xil_axi_uint&nbsp;</td><td class=\"PName last\">new_timeout</td></tr></table></td><td class=\"PAfterParameters\">);</td></tr></table></div><div class=\"TTSummary\">Sets the number of cycles that the driver will wait for AW/W/B accepted until it will flag a watch dog error of the axi_mst_wr_driver. Default value is 50000. Setting this to a very large value will cause a hung simulation to continue for a longer time.&nbsp; Setting this to a very small number may not allow enough time for simulation to respond.</div></div>",1004:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype1004\" class=\"NDPrototype WideForm CStyle\"><table><tr><td class=\"PBeforeParameters\"><span class=\"SHKeyword\">function void</span> set_forward_progress_timeout_value (</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">input&nbsp;</td><td class=\"PType\">xil_axi_uint&nbsp;</td><td class=\"PName last\">new_timeout</td></tr></table></td><td class=\"PAfterParameters\">);</td></tr></table></div><div class=\"TTSummary\">Sets the number of cycles that the driver will wait until it will flag a watch dog error of the &lt;axi_mst_rd_driver&gt;.Default value is 50000.</div></div>",1008:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype1008\" class=\"NDPrototype WideForm CStyle\"><table><tr><td class=\"PBeforeParameters\"><span class=\"SHKeyword\">function void</span> set_forward_progress_timeout_value (</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">input&nbsp;</td><td class=\"PType\">xil_axi_uint&nbsp;</td><td class=\"PName last\">new_timeout</td></tr></table></td><td class=\"PAfterParameters\">);</td></tr></table></div><div class=\"TTSummary\">Sets the number of cycles that the driver will wait for AW/W/B accepted until it will flag a watch dog error of the axi_slv_wr_driver. Default value is 50000. Setting this to a very large value will cause a hung simulation to continue for a longer time.&nbsp; Setting this to a very small number may not allow enough time for simulation to respond.</div></div>",1011:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype1011\" class=\"NDPrototype WideForm CStyle\"><table><tr><td class=\"PBeforeParameters\"><span class=\"SHKeyword\">function void</span> set_forward_progress_timeout_value (</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">input&nbsp;</td><td class=\"PType\">xil_axi_uint&nbsp;</td><td class=\"PName last\">new_timeout</td></tr></table></td><td class=\"PAfterParameters\">);</td></tr></table></div><div class=\"TTSummary\">Sets the number of cycles that the driver will wait until it will flag a watch dog error of the axi_slv_rd_driver. Default value is 50000. Setting this to a very large value will cause a hung simulation to continue for a longer time.&nbsp; Setting this to a very small number may not allow enough time for simulation to respond.</div></div>",1017:"<div class=\"NDToolTip TClass LSystemVerilog\"><div class=\"TTSummary\">AXI Slave Read Driver Class. It does below: Receives AR Command from the interface and then passes that command to the user environment. The user will then create a READ transaction and pass it back to the driver to drive the R channel.</div></div>",1039:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype1039\" class=\"NDPrototype WideForm CStyle\"><table><tr><td class=\"PBeforeParameters\">task send_wready(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">input&nbsp;</td><td class=\"PType\">axi_ready_gen&nbsp;</td><td class=\"PName last\">t</td></tr></table></td><td class=\"PAfterParameters\">);</td></tr></table></div><div class=\"TTSummary\">Sends the ready structure to the slave write driver for controlling the WREADY channel.This is blocking process which will not return till this ready is being sent out.</div></div>",1043:"<div class=\"NDToolTip TClass LSystemVerilog\"><div class=\"TTSummary\">AXI Memory Model class. It is an associate array of Systemverilog. The write transaction can write to the memory and the read transaction can read data from the memory. These two features are implemented in the Slave VIP and Passthrough VIP in runtime slave mode. At the same time, the memory model has backdoor APIs for user to access memory directly. Please refer PG267 section about Simple SRAM Memory Model for more details.</div></div>",1070:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype1070\" class=\"NDPrototype WideForm CStyle\"><table><tr><td class=\"PBeforeParameters\">task send_awready(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">input&nbsp;</td><td class=\"PType\">axi_ready_gen&nbsp;</td><td class=\"PName last\">t</td></tr></table></td><td class=\"PAfterParameters\">);</td></tr></table></div><div class=\"TTSummary\">Sends the ready structure to the slave write driver for controlling the AWREADY channel.his is blocking process which will not return till this ready is being sent out.</div></div>",1101:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype1101\" class=\"NDPrototype NoParameterForm\"><span class=\"SHKeyword\">virtual function</span> xil_axi_uint get_event_count();</div><div class=\"TTSummary\">Returns event_count of axi_ready_gen. event count is used when policy is XIL_AXI_READY_RAND_AFTER_VALID_EVENTS. refer xil_axi_ready_gen_policy_t about how event_count works.</div></div>",1112:"<div class=\"NDToolTip TClass LSystemVerilog\"><div class=\"TTSummary\">AXI Slave Agent Class.</div></div>",1133:"<div class=\"NDToolTip TClass LSystemVerilog\"><div class=\"TTSummary\">AXI Monitor Transaction class. It is an extension of axi_transaction with more APIs added for monitor purpose.</div></div>",1139:"<div class=\"NDToolTip TClass LSystemVerilog\"><div class=\"TTSummary\">AXI Slave Agent with Memory model.</div></div>",1163:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype1163\" class=\"NDPrototype WideForm CStyle\"><table><tr><td class=\"PBeforeParameters\">task send_rready(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">input&nbsp;</td><td class=\"PType\">axi_ready_gen&nbsp;</td><td class=\"PName last\">t</td></tr></table></td><td class=\"PAfterParameters\">);</td></tr></table></div><div class=\"TTSummary\">Sends the ready structure to the driver for controlling the READY channel of axi_mst_rd_driver.&nbsp; Usually user would create a new axi_ready_gen by calling create_ready of axi_mst_rd_driver, either randomize the rready or set it up manually. Then it calls send to send the rready to axi_mst_rd_driver.</div></div>",1164:"<div class=\"NDToolTip TClass LSystemVerilog\"><div class=\"TTSummary\">AXI Master Agent class.</div></div>"});