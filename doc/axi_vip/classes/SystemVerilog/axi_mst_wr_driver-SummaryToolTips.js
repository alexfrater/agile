NDSummary.OnToolTipsLoaded("SystemVerilogClass:axi_mst_wr_driver",{714:"<div class=\"NDToolTip TClass LSystemVerilog\"><div class=\"TTSummary\">AXI Master Write Driver class.</div></div>",885:"<div class=\"NDToolTip TInformation LSystemVerilog\"><div class=\"TTSummary\">axi_vif_mem_proxy `AXI_PARAM_ORDER&nbsp; vif_proxy; AXI VIF Proxy Class</div></div>",887:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype887\" class=\"NDPrototype WideForm CStyle\"><table><tr><td class=\"PBeforeParameters\"><span class=\"SHKeyword\">function new</span>(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PType first\"><span class=\"SHKeyword\">string</span>&nbsp;</td><td class=\"PName\">name&nbsp;</td><td class=\"PDefaultValueSeparator\">=&nbsp;</td><td class=\"PDefaultValue last\"><span class=\"SHString\">&quot;unnamed_axi_mst_wr_driver&quot;</span></td></tr></table></td><td class=\"PAfterParameters\">);</td></tr></table></div><div class=\"TTSummary\">Constructor to create a new AXI master write driver axi_mst_wr_driver. ~name~ is the name of the instance.</div></div>",883:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype883\" class=\"NDPrototype WideForm CStyle\"><table><tr><td class=\"PBeforeParameters\"><span class=\"SHKeyword\">function void</span> set_vif(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">axi_vif_mem_proxy `</td><td class=\"PType\">AXI_PARAM_ORDER&nbsp;</td><td class=\"PName last\">vif</td></tr></table></td><td class=\"PAfterParameters\">);</td></tr></table></div><div class=\"TTSummary\">Assigns the virtual interface vif to the virtual interface of axi_mst_wr_driver.</div></div>",413:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype413\" class=\"NDPrototype WideForm CStyle\"><table><tr><td class=\"PBeforeParameters\"><span class=\"SHKeyword\">function void</span> set_bready_gen(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">input&nbsp;</td><td class=\"PType\">axi_ready_gen_t&nbsp;</td><td class=\"PName last\">new_gen</td></tr></table></td><td class=\"PAfterParameters\">);</td></tr></table></div><div class=\"TTSummary\">Sets bready of the AXI master write driver. There are three ways for bready generation in AXI master write driver.</div></div>",890:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype890\" class=\"NDPrototype NoParameterForm\"><span class=\"SHKeyword\">function</span> axi_ready_gen_t get_bready_gen();</div><div class=\"TTSummary\">Returns bready_gen of the axi_mst_wr_driver.</div></div>",1000:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype1000\" class=\"NDPrototype WideForm CStyle\"><table><tr><td class=\"PBeforeParameters\"><span class=\"SHKeyword\">function void</span> set_forward_progress_timeout_value (</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">input&nbsp;</td><td class=\"PType\">xil_axi_uint&nbsp;</td><td class=\"PName last\">new_timeout</td></tr></table></td><td class=\"PAfterParameters\">);</td></tr></table></div><div class=\"TTSummary\">Sets the number of cycles that the driver will wait for AW/W/B accepted until it will flag a watch dog error of the axi_mst_wr_driver. Default value is 50000. Setting this to a very large value will cause a hung simulation to continue for a longer time.&nbsp; Setting this to a very small number may not allow enough time for simulation to respond.</div></div>",1001:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype1001\" class=\"NDPrototype NoParameterForm\"><span class=\"SHKeyword\">function</span> xil_axi_uint get_forward_progress_timeout_value ();</div><div class=\"TTSummary\">Returns the number of cycles that the driver will wait for AW/W/B accepted until it will flag a watch dog error of the axi_mst_wr_driver. Default value is 50000 and user can use set_forward_progress_timeout_value to change it.</div></div>",945:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype945\" class=\"NDPrototype WideForm CStyle\"><table><tr><td class=\"PBeforeParameters\"><span class=\"SHKeyword\">function void</span> set_waiting_valid_timeout_value (</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">input&nbsp;</td><td class=\"PType\">xil_axi_uint&nbsp;</td><td class=\"PName last\">new_timeout</td></tr></table></td><td class=\"PAfterParameters\">);</td></tr></table></div><div class=\"TTSummary\">Sets waiting_valid_timeout_value of the &lt;axi_mst_wr_driver&gt;.waiting_valid_timeout_value is used for driver to wait a certain number of cycles for bvalid/bready, awvalid/awready and wvalid/wready handshake occurs before it time out.</div></div>",894:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype894\" class=\"NDPrototype NoParameterForm\"><span class=\"SHKeyword\">function</span> xil_axi_uint get_waiting_valid_timeout_value ();</div><div class=\"TTSummary\">Returns waiting_valid_timeout_value of the axi_mst_wr_driver. waiting_valid_timeout_value is used for driver to wait a certain number of cycles for bvalid/bready, awvalid/awready and wvalid/wready handshake occurs before it time out.</div></div>",950:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div class=\"TTSummary\">Sets the maximum number of WRITE transactions that the axi_mst_wr_driver will have in flight at one time.</div></div>",896:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div class=\"TTSummary\">Returns the maximum number of WRITE transactions that the axi_mst_wr_driver will have in flight at one time.</div></div>",953:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype953\" class=\"NDPrototype WideForm CStyle\"><table><tr><td class=\"PBeforeParameters\"><span class=\"SHKeyword\">function void</span> set_awaddr_watchdog_delay(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">input&nbsp;</td><td class=\"PType\">xil_axi_uint&nbsp;</td><td class=\"PName last\">new_depth</td></tr></table></td><td class=\"PAfterParameters\">);</td></tr></table></div><div class=\"TTSummary\">Sets awaddr_watchdog_delay of the axi_mst_wr_driver. When axi_transaction\'s xfer_wrcmd_order is XIL_AXI_WRCMD_ORDER_DATA_BEFORE_CMD and get_allow_data_before_cmd() greater than zero, AW channel of axi_mst_wr_driver will fire watchdog AXI_WR_MST_ORDER_DATA_BEFORE_CMD WATCHDOG fired if it doesn\'t see enough beat_counts as desired after waiting awaddr_watchdog_delay clock cycles.</div></div>",770:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype770\" class=\"NDPrototype NoParameterForm\"><span class=\"SHKeyword\">function</span> xil_axi_uint get_awaddr_watchdog_delay();</div><div class=\"TTSummary\">Returns awaddr_watchdog_delay of the &lt;axi_mst_wr_driver&gt;.awaddr_watchdog_delay is the number of clock cycles axi_mst_wr_driver waits before it fires watchdog AXI_WR_MST_ORDER_DATA_BEFORE_CMD when AW channel does not have enough payload beats.</div></div>",899:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype899\" class=\"NDPrototype NoParameterForm\"><span class=\"SHKeyword\">virtual function</span> xil_axi_boolean_t get_adjust_addr_delay_enabled();</div><div class=\"TTSummary\">Returns the current state of adjust_addr_delay_enabled.</div></div>",900:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype900\" class=\"NDPrototype WideForm CStyle\"><table><tr><td class=\"PBeforeParameters\"><span class=\"SHKeyword\">virtual function void</span> set_adjust_addr_delay_enabled(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">input&nbsp;</td><td class=\"PType\">xil_axi_boolean_t&nbsp;</td><td class=\"PName last\">update</td></tr></table></td><td class=\"PAfterParameters\">);</td></tr></table></div><div class=\"TTSummary\">Sets the value of adjust_addr_delay_enabled of the transaction.</div></div>",901:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype901\" class=\"NDPrototype NoParameterForm\"><span class=\"SHKeyword\">virtual function</span> xil_axi_boolean_t get_adjust_data_beat_delay_enabled();</div><div class=\"TTSummary\">Returns the current state of adjust_data_beat_delay_enabled.</div></div>",902:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype902\" class=\"NDPrototype WideForm CStyle\"><table><tr><td class=\"PBeforeParameters\"><span class=\"SHKeyword\">virtual function void</span> set_adjust_data_beat_delay_enabled(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">input&nbsp;</td><td class=\"PType\">xil_axi_boolean_t&nbsp;</td><td class=\"PName last\">update</td></tr></table></td><td class=\"PAfterParameters\">);</td></tr></table></div><div class=\"TTSummary\">Sets the value of adjust_data_beat_delay_enabled of the transaction.</div></div>",871:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype871\" class=\"NDPrototype NoParameterForm\"><span class=\"SHKeyword\">function</span> xil_axi_boolean_t is_driver_idle();</div><div class=\"TTSummary\">Returns TRUE if driver is idle(no outstanding write command from write address channel, no outstanding data from write data channel,no outstanding write response from write response channel), else FALSE.</div></div>",904:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype904\" class=\"NDPrototype NoParameterForm\"><span class=\"SHKeyword\">function</span> xil_axi_uint get_num_transactions_inflight();</div><div class=\"TTSummary\">Returns number of transactions in flight</div></div>",905:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype905\" class=\"NDPrototype NoParameterForm\">task run_phase();</div><div class=\"TTSummary\">Start control processes for operation of axi_mst_wr_driver.</div></div>",906:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype906\" class=\"NDPrototype NoParameterForm\"><span class=\"SHKeyword\">virtual</span> task stop_phase();</div><div class=\"TTSummary\">Stops all control processes of axi_mst_wr_driver.</div></div>",907:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype907\" class=\"NDPrototype NoParameterForm\"><span class=\"SHKeyword\">virtual</span> task halt_phase();</div><div class=\"TTSummary\">Allows for all inflight transactions to complete and no new transaction will be serviced. All other transactions will halt in axi_mst_wr_driver.</div></div>",908:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype908\" class=\"NDPrototype NoParameterForm\"><span class=\"SHKeyword\">virtual</span> task resume_phase();</div><div class=\"TTSummary\">Resumes processing of the pending transactions in axi_mst_wr_driver.</div></div>",957:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype957\" class=\"NDPrototype WideForm CStyle\"><table><tr><td class=\"PBeforeParameters\">task send(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">input&nbsp;</td><td class=\"PType\">axi_transaction&nbsp;</td><td class=\"PName last\">t</td></tr></table></td><td class=\"PAfterParameters\">);</td></tr></table></div><div class=\"TTSummary\">Sends the AXI transaction to axi_mst_wr_driver. Usually user would create a new axi_transaction by calling create_transaction of axi_mst_wr_driver, either randomize the transaction or set it up. Then it calls send to send the transaction to axi_mst_wr_driver.&nbsp; It is a blocking process. please refer example design for the usage</div></div>",958:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype958\" class=\"NDPrototype WideForm CStyle\"><table><tr><td class=\"PBeforeParameters\">task wait_rsp(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">output&nbsp;</td><td class=\"PType\">axi_transaction&nbsp;</td><td class=\"PName last\">t</td></tr></table></td><td class=\"PAfterParameters\">);</td></tr></table></div><div class=\"TTSummary\">This blocking function will not return until driver send back response transaction of &lt;axi_mst_wr_driver&gt;.please refer example design for the usage.</div></div>",959:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype959\" class=\"NDPrototype WideForm CStyle\"><table><tr><td class=\"PBeforeParameters\"><span class=\"SHKeyword\">virtual function</span> axi_transaction create_transaction (</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PType first\"><span class=\"SHKeyword\">string</span>&nbsp;</td><td class=\"PName\">name&nbsp;</td><td class=\"PDefaultValueSeparator\">=&nbsp;</td><td class=\"PDefaultValue last\"><span class=\"SHString\">&quot;unnamed_transaction&quot;</span></td></tr></table></td><td class=\"PAfterParameters\">);</td></tr></table></div><div class=\"TTSummary\">Returns an axi transaction class that has been &quot;newed&quot; of &lt;axi_mst_wr_driver&gt;.please refer example design for the usage.</div></div>",960:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype960\" class=\"NDPrototype WideForm CStyle\"><table><tr><td class=\"PBeforeParameters\">task send_bready(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PModifierQualifier first\">input&nbsp;</td><td class=\"PType\">axi_ready_gen&nbsp;</td><td class=\"PName last\">t</td></tr></table></td><td class=\"PAfterParameters\">);</td></tr></table></div><div class=\"TTSummary\">Sends the ready structure to the axi_mst_wr_driver for controlling the READY channel.&nbsp; Usually user would create a new axi_ready_gen by calling create_ready of axi_mst_wr_driver, either randomize the bready or set it up manually. Then it calls send to send the bready to axi_mst_wr_driver.</div></div>",913:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype913\" class=\"NDPrototype WideForm CStyle\"><table><tr><td class=\"PBeforeParameters\"><span class=\"SHKeyword\">virtual function</span> axi_ready_gen create_ready (</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PType first\"><span class=\"SHKeyword\">string</span>&nbsp;</td><td class=\"PName\">name&nbsp;</td><td class=\"PDefaultValueSeparator\">=&nbsp;</td><td class=\"PDefaultValue last\"><span class=\"SHString\">&quot;unnamed_ready&quot;</span></td></tr></table></td><td class=\"PAfterParameters\">);</td></tr></table></div><div class=\"TTSummary\">Returns a ready class that has been &quot;newed&quot; of axi_mst_wr_driver.</div></div>",914:"<div class=\"NDToolTip TFunction LSystemVerilog\"><div id=\"NDPrototype914\" class=\"NDPrototype NoParameterForm\">task wait_driver_idle();</div><div class=\"TTSummary\">This is a blocking task which will wait until there are no outstanding transactions in the axi_mst_wr_driver. This means that all the transactions send to the driver have received a corresponding B channel response.</div></div>"});